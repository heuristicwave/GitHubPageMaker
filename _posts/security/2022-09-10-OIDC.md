---
layout: post
current: post
cover:  assets/built/images/background/OIDC.png
navigation: True
title: The Journey to Know OIDC (작성중)
date: 2022-09-13 00:00:00
tags: [security]
class: post-template
subclass: 'post tag-backend'
author: HeuristicWave
---

Journey to OIDC through authentication, authorization, SAML, and OAuth.

<br>

## Intro

요즘 제 일상에서, OIDC(OpenID Connect)에 대해 많은 이야기가 오고갔습니다. 그동안 동작 원리도 제대로 알지 못한채 사용하고 있던 제 모습을 반성하며,
OIDC를 알아가기 위해 조사한 내용들을 다뤄보겠습니다.

<br>

## 🥾 Authentication & Authorization

OIDC를 향한 여정의 첫걸음은 인증과 인가입니다. 국어로도 비슷한 두 단어는 영어로도 비슷하며 다음과 같이 줄여서 표현하기도 합니다.
AuthN(인증) & AuthZ(인가, 권한 부여)

인증과 인가에 관한 설명은 온라인에 굉장히 많지만, 저는 그 중에서도 [**Auth0(오스제로)**사의 문서의 비교표](https://auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization#authentication-vs-authorization )를 인용하였습니다.

|  Authentication | Authorization  |
|---|---|
| 사용자가 자신이 주장하는 사람이 맞는지 결정합니다. | 사용자가 접근 할 수 있는지 없는지 결정합니다. |
| 사용자의 자격증명이 유효한지 확인합니다. | 정책과 룰을 통해 접근 여부를 확인합니다. |
| 통상 인가 전 단계에 진행합니다. | 통상 인증 이후 단계에 진행합니다. |
| 일반적으로 **ID Token**을 통해 정보를 전송합니다. | 일반적으로 **Access Token**을 통해 정보를 전달합니다. |
| 일반적으로 **OIDC 프로토콜**에 의해 관리됩니다. | 일반적으로 **OAuth 2.0 프레임워크**에 의해 관리됩니다. |

> 💡 위 비교표에 **Bold**처리 된 키워드가 오늘 포스팅을 이해하기 위한 핵심 용어이므로 주목해주세요!

<br>

## ⛰ OAuth 2.0

**OAuth 2.0 Authorization Framework**의 [RFC 문서](https://www.rfc-editor.org/rfc/rfc6749 )의 Abstract 부분을 확인하면 다음과 같이 정의합니다.
*"OAuth 2.0 인가 프레임워크는 서드파티 앱들이 제한된 권한을 얻는 것을 가능하게 해줍니다."*

여러분들은 특정 서비스회사의 어플리케이션을 이용할 때, 구글이나 페이스북으로부터 특정 권한을 받아 서비스를 이용한 경험이 있을 것 입니다.
**구글 계정** 정보의 [내 계정에 액세스할 수 있는 앱](https://myaccount.google.com/permissions )에 들어가 확인해 보시면,
내 계정이 어떤 앱들이 액세스 할 수 있게 권한을 주었는지 확인 가능 합니다.

![OAuth 2.0](../../assets/built/images/post/security/oauth.png)

위 사진을 통해, 구글이 **OAuth 프레임워크**를 사용해 Meetup, Notion, Slack과 같은 **서드파티 앱**들에게
계정의 이메일 주소확인, 개인정보 보기 등과 같은 **제한된 권한**에 대하여 **인가**를 해줬다는 사실을 알 수 있습니다.

### Slack으로 알아보는 OAuth 2.0 Flow

OAuth에 워크플로를 알아보기 전에, 자주 언급되는 핵심 용어들을 언급하고 넘어가겠습니다.

- Client : 인가를 받는 애플리케이션 (배달의 민족, 야놀자, 오늘의 집 등)
- Resource Server : 제어하고자 하는 자원(Protected Resource)을 가진 서버 (구글, 페이스북, 깃헙)
- Resource Owner : 자원의 소유자 (end-user)
- Authorization Server : AuthZ 처리를 하는 서버

다시 [RFC 문서](https://www.rfc-editor.org/rfc/rfc6749 )로 돌아와서 해당 프로토콜의 Flow를 앞서 보여드린 예시처럼 우리의 경험에 빗대어 설명해보겠습니다.

```shell
# Abstract Protocol Flow
+--------+                               +---------------+
|        |--(A)- Authorization Request ->|   Resource    |
|        |                               |     Owner     |
|        |<-(B)-- Authorization Grant ---|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(C)-- Authorization Grant -->| Authorization |
| Client |                               |     Server    |
|        |<-(D)----- Access Token -------|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(E)----- Access Token ------>|    Resource   |
|        |                               |     Server    |
|        |<-(F)--- Protected Resource ---|               |
+--------+                               +---------------+
```

A & B에 해당하는 Client가 Resource Owner에게 AuthZ를 요청하고 승인 절차를 Slack 로그인을 통해서 알아보겠습니다.

![login](../../assets/built/images/post/security/googleOAuth.png)

위 이미지에서 Client인 slack은 Google과 Apple 2가지 방식의 OAuth를 제공합니다.
'Google로 계속'이라는 버튼(A단계, AuthZ 요청)을 누르면, slack이 계정의 이름, 이메일, 프로필 사진 등의 정보 공유를 요청했다는 것을 구글의 Authorization Server로부터 받습니다.
해당 시점의 웹브라우저 URI를 확인 하면 다음과 같습니다. *(편의상 URI을 쿼리스트링 단위로 나누고, Decode하여 표기했습니다.)*

```shell
https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount? \ 
  client_id=6XXXXXXXX.apps.googleusercontent.com& \
  redirect_uri=https://oauth2.slack.com/get-started/oauth/google/end& \
  scope=openid email profile& \
  response_type=code& \
  access_type=offline& \
  state=& \
  prompt=consent& \
  flowName=GeneralOAuthFlow
```

슬랙의 권한 부여의 경우, `https://accounts.google.com/{이하 생략}` 이라는 Authorization Server의 주소와 `client_id`를 포함한 8개의 querystring으로 구성되어 있습니다.
여기서 상위 4개의 querystring은 인가를 위한 **필수 파라미터** 입니다.

- `client_id` : client를 식별하기 위해 Register 단계에서 생성된 애플리케이션의 식별자
- `redirect_uri` : authorization code를 전달 받을 client 서버의 URI
- `scope` : 인가할 권한을 명시
- `response_type` : code, token 등 OAuth에 적용할 방식의 타입

캡처화면에서는 우리의 웹 브라우저를 통해 A와 B의 단계가 클릭 2번으로 끝나지만, 사실 A와 B사이에는 더 복잡한 단계들이 숨겨져 있습니다.
아래 RFC 문서에 기재된 **Implicit Grant Flow**를 살펴보며 A 이후의 단계들을 살펴 보겠습니다. 

```shell
# Implicit Grant Flow
 +----------+
 | Resource |
 |  Owner   |
 |          |
 +----------+
      ^
      |
     (B)
 +----|-----+          Client Identifier     +---------------+
 |         -+----(A)-- & Redirection URI --->|               |
 |  User-   |                                | Authorization |
 |  Agent  -|----(B)-- User authenticates -->|     Server    |
 |          |                                |               |
 |          |<---(C)--- Redirection URI ----<|               |
 |          |          with Access Token     +---------------+
 |          |            in Fragment
 |          |                                +---------------+
 |          |----(D)--- Redirection URI ---->|   Web-Hosted  |
 |          |          without Fragment      |     Client    |
 |          |                                |    Resource   |
 |     (F)  |<---(E)------- Script ---------<|               |
 |          |                                +---------------+
 +-|--------+
   |    |
  (A)  (G) Access Token
   |    |
   ^    v
 +---------+
 |         |
 |  Client |
 |         |
 +---------+
```

간략하게 몇 가지를 더 설명하자면, 위 승인 Flow의 User-Agent는 우리의 웹브라우저 입니다.
User-Agent와 인가 서버 사이에서 querystring에 담긴 `client_id`와 `redirect_uri`를 가지고 **검증** 작업을 하며, 이후 생성된 **Access Token**을 활용해
scope에 명시된 기능을 Resource Server로 부터 제공받습니다. 해당 절차가 `Abstract Protocol Flow` 그림의 B ~ F에 해당합니다.

> 🛎 위 2가지 Flow가 OAuth 2.0의 전체 Flow는 아닙니다. Autorization Code, Refresh Token 등 **중요 개념들이 상당히 생략** 되어 있습니다.

### More Information

지금까지 생소한 정보들을 쏟아내다 보니, 독자 여려분들이 굉장히 혼란스러울 것 같습니다. (처음 OAuth를 공부했던 제가 그랬습니다 😵‍💫)
이 시점에서 okta의 identity-101 문서인 [SAML vs. OAuth: Comparison and Differences](https://www.okta.com/identity-101/saml-vs-oauth/ )를 읽는 것을 추천드립니다.

<br>

## OpenID Connect(OIDC)

얼렁뚱땅 OAuth를 넘기고 드디어 OpenID Connect 순서에 다다르었습니다. OIDC를 다루기 전, **OpenID**가 무엇인지 [OpenID 재단의 설명](https://openid.net/what-is-openid/ )에서 몇가지 살펴보겠습니다.

### OpenID

- OpenID는 새 비밀번호를 만들 필요 없이, 기존 계정을 사용해 여러 웹사이트에 로그인 할 수 있습니다.
- OpenID를 사용하면 웹사이트와 공유되는 정보의 양을 제어할 수 있습니다.
- 당신의 비밀번호은 Identity provider(Idp)에게만 주어지며, Idp가 신원을 확인하므로 안전하지 않은 웹사이트가 당신의 신원을 훼손하는 것에 대해 걱정할 필요가 없습니다.

> ⚡️ OpenID 2.0은 OpenID Connect로 대체되었습니다. [Ref. Libraries for Obsolete Specifications](https://openid.net/developers/libraries/obsolete/)

### OAuth 2.0

이어서, [OpenID 재단의 설명](https://openid.net/connect/ )의 OIDC는 다음과 같이 정의 되어 있습니다.
"OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol." OIDC가 OAuth 프로토콜의 상위 간단한 신원 계층이라는 말이 무엇을 의미할까요?
여기서 앞서 slack 예시에서 만난 OAuth의 `scope` 부분으로 거슬러 올라가 보겠습니다. (`scope=openid email profile`) 해당 파라미터에는 인가할 리소스가 `openid`로 기재되어 있습니다.
즉, slack은 제 프로필 정보를 얻기 위해 **OAuth 2.0**을 사용해 `Google OAuth2 API v2`를 호출했고, 액세스 하려는 API의 `scope`을 `openid`로 지정했습니다. 

Playground & id_token

## Outro

SDS, ODC
레퍼런스 붙이기

소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해주세요! 😃

---
